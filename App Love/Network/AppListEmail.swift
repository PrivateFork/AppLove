//
//  AppListEmail.swift
//  App Love
//
//  Created by Woodie Dovich on 2016-07-27.
//  Copyright © 2016 Snowpunch. All rights reserved.
//

import UIKit
import MessageUI

class AppListEmail: NSObject {

    class func generateAppList() -> MFMailComposeViewController {
        
        let mailComposerVC = MFMailComposeViewController()
        mailComposerVC.setSubject("App Links")
        
        var msgBody = "<small><b>Check out these Apps!</b><br></small>"
        let appModels = AppList.sharedInst.appModels

        for app in appModels {
            msgBody += AppListEmail.getAppLink(app)
        }
        
        let appLoveLink = "<small><a href='https://itunes.apple.com/app/id\(Const.appId.AppLove)'><br>List generated by 'App Love'</a></small>"
        
        msgBody += appLoveLink
        
        mailComposerVC.setMessageBody(msgBody, isHTML: true)
        return mailComposerVC
    }
    
    class func truncateAppName(originalAppName:String?) -> String {
        let fullAppName = originalAppName ?? ""
        let fullNameArray = fullAppName.characters.split("-").map{ String($0) }
        var appName = fullNameArray.first ?? ""
        if appName != fullAppName {
            appName = appName + "..."
        }
        
        let truncatedAppName = appName.truncate(30)
        return truncatedAppName
    }
    
    class func getAppLink(app:AppModel) -> String {
        let appName = truncateAppName(app.appName)
        return "<small><a href='https://itunes.apple.com/app/id\(app.appId)'>\(appName)</a></small><br>"
    }
}

// gist from gitgub
private extension String {
    /// Truncates the string to length number of characters and
    /// doesn't truncate within a word.
    /// appends optional trailing string if longer
    func truncate(length: Int, wordSeparator: String = " ", trailing: String = "…") -> String {
        
        if self.characters.count > length {
            let words = self.componentsSeparatedByString(wordSeparator)
            var cumulativeCharacters = 0
            var wordsToInclude:[String] = []
            for word in words {
                cumulativeCharacters += word.lengthOfBytesUsingEncoding(NSUTF8StringEncoding) + 1
                if cumulativeCharacters < length {
                    //puts("cumulativeCharacters: \(cumulativeCharacters), length: \(length)")
                    wordsToInclude.append(word)
                } else {
                    return wordsToInclude.joinWithSeparator(wordSeparator) + trailing
                }
                
            }
            return self.substringToIndex(self.startIndex.advancedBy(length)) + trailing
        } else {
            return self
        }
    }
}